# RB101 Quick Notes

- `.inspect` is handy to see what is happening with an object
- This type of assignment, where we assign more than one value on the same line, is called "multiple assignment".

## Misc extending lesson flowchart tool
Mermaid Syntax: 

```mermaid
graph TD
A(Start/Stop) --> 
B[processing step] -->
C>input/output] -->
D{decision} -->
E((connector))

```


## Review Styles, Concepts, Syntax or Logic
--------------------------------------------
### Pseudo Code

> When you first approach any problem, it's important to try to understand it well. In order to do that, you have to spend time to load the problem into your brain. Only then can you start to dissect it, understand it, and come up with an execution path to solve it.

> Therefore, there are two layers to solving any problem:
> 1. The logical problem domain layer.
> 2. The syntactical programming language layer.

> -- <cite>[Pseudo-Code](https://launchschool.com/lessons/a0f3cd44/assignments/18adce3e)</cite>

***

> We'll use the below keywords to assist us, along with their meaning.

| keyword | meaning |
| --- | --- |
| START | start of the program |
| SET | sets a variable we can use for later |
| GET | retrieve input from user |
| PRINT | displays output to user |
| READ | retrieve value from variable |
| IF / ELSE IF / ELSE | show conditional branches in logic |
| WHILE | show looping logic |
| END | end of the program |

#### [Flowchart](https://launchschool.com/lessons/a0f3cd44/assignments/cfbf3863)

Come back to this and review the logic that they explain thoroughly. It's a new approach so best to take this one in a piecemeal style
> The interesting part about this flowchart is the processing square in the middle num = find_largest(collection). This is our sub-process. You can think of this square as the zoomed-out high level view of the very first flowchart from the top of this assignment.

> Interestingly, when we move logic to sub-processes, we are able to use a declarative type of syntax, rather than imperative. 

> -- <cite>[Flowchart](https://launchschool.com/lessons/a0f3cd44/assignments/cfbf3863)</cite>

***

#### [Debugging](https://launchschool.com/lessons/a0f3cd44/assignments/e742d62a)

Steps to Debugging:
1. Reproduce The Error: 
The first step in debugging any problem is usually reproducing the problem. Programmers need a deterministic way to consistently reproduce the problem, and only then can we start to isolate the root cause. There's an old joke where programmers will say "works on my machine" because they can't reproduce an error that occurs in the production environment. This will become more important as you build more sophisticated applications with various external dependencies and moving parts. Reproducing the exact error will often end up being more than half the battle in many tricky situations.

2. Determine The Boundaries Of The Error: 
Once you can consistently reproduce the problem, it's time to tweak the data that caused the error. For example, the stack trace earlier was generated by this code post.categories << news. Does calling post.categories cause issues? What about just calling post? What happens if we try to append a different object, like this: post.categories << sports? How does modifying the data affect the program behavior? Do we get expected errors, or does a new error occur that sheds light on the underlying problem?

What we're trying to do is modify the data or code to get an idea of the scope of the error and determine the boundaries of the problem. This will lead to a deeper understanding of the problem, and allow us to implement a better solution. Most problems can be solved in many ways, and the deeper you understand the problem, the more holistic solution you can come up with.

3. Trace the Route:

4. Understand The Problem Well

5. Implement a Fix